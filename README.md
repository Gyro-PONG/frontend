# Gyro-PONG

![title](/readme_assets/title.jpg)
gyro-pong은 모바일 기기의 자이로 센서를 이용하여 PONG 게임을 할 수 있는 웹 사이트입니다.  
즉 모바일 기기의 기울임으로서 게임을 플레이할 수 있습니다.

&nbsp;

## 사이트 방문하기

https://www.gyropong.com/

&nbsp;

## 제작동기

웹은 탄생 이후 지금까지 획기적인 발전 과정을 거쳤습니다.  
하지만 웹을 조작하는 방법은 예전과 크게 달라지지 않다는 것을 느꼈습니다.  
버튼을 누르거나, 특정 디바이스를 이용하여 수평면으로만 움직이는게 전부였기 때문입니다.

물론 터치스크린의 등장으로 인해 손으로 직접 웹을 만지며 조작이 가능해졌지만,  
누름, 그리고 평면으로 움직임이는 방법을 사용한다는 점에서  
터치스크린 역시 웹을 조작하는데에는 기존과 크게 다르지 않다고 생각했습니다.

단순한 움직임으로 웹을 조작하는 기존의 패러다임에서 탈피하여  
좀 더 다채롭고 역동적으로 웹을 조작하고 싶다는 생각이 들었고,  
이런 발상을 기반으로 하여 프로젝트를 기획하였습니다.

'역동적인 움직임', '누군가와 함께 즐기는 활동'  
이런 주제로 방향을 잡다보니 게임으로 가닥이 잡혔고,

'처음 선보이는 것', '새로운 것'이라는 키워드에 초점을 맞추니  
최초의 아케이드 게임인 PONG이 떠올랐습니다.

결과적으로 서로 다른 두 개의 소재가 만나  
모션을 통해 움직이는 웹 게임 Gyro PONG을 개발하였습니다.

&nbsp;

## 기술스텍

### Frontend

- `React`
- `Recoil`
  - 이번 프로젝트에서는 복잡한 전역상태관리를 크게 요구하지 않기 때문에
    기존에 주로 사용한 ReduxToolkit 보다 더욱 간편하게 사용할 수 있는 상태관리 도구를 사용해보고자 하였습니다.  
    다양한 tool 중에서도, recoil이 react에 친화적이며, 러닝 커브가 높지 않고,  
    무엇보다 지금까지 한 번도 사용해본 적이 없었기 때문에 recoil을 사용해볼 좋은 기회인 것 같아 도입하였습니다.
- `Styled-components`
- `Socket.Io-Client`
- `Canvas`
- `React-testing-library`
- `Netlify 배포`

### Backend

- `Express`
- `Socket.Io`
- `Supertest`
- `Chai`
- `Mocha`
- `AWS 배포`

&nbsp;

## 개발 기간

- 기획
  - 22/06/27 ~ 22/07/01  
    &nbsp;
- 제작
  - 22/07/02 ~ 22/07/16

&nbsp;

## 어려웠던 점

### Paddle이 움직이는 범위 컨트롤하기

모바일 기기를 가로로 쥔 상태로 왼쪽, 혹은 오른쪽으로 돌리면,  
기울인 각도 만큼 게임 내 Paddle이 좌 우로 움직이도록 기획하였습니다.

하지만 정확히 어느 각도만큼 최대한 기울여야 되는지,  
그 수치를 정하는 기준을 세우는게 애매하였기 때문에  
어느 정도까지 기울여야 게임성을 살리면서도 손이 불편하지는 않는지 생각하는 것이  
초반 개발 단계에서의 주된 고민거리였습니다.

고심끝에 내린 결론은 '사람마다 다르다' 였습니다.  
사람마다 신체 구조가 다르기 때문입니다.  
따라서 최대 움직임 각도를 고정된 상수로 정하는 대신, 맨 처음 모바일 기기를 등록하는 단계에서  
최대 움직임 각도를 측정하게끔 하였습니다.

결과적으로 이런 고민 과정을 통해  
웹을 사용하는 사용자의 경험에 대해 다시 한 번 고찰해볼 수 있었습니다.

&nbsp;

### 각기 다른 모니터 화면 대응하기

모두가 똑같은 사이즈의, 똑같은 픽셀 밀도의 모니터를 가지고 웹을 이용하지 않기 때문에  
이를 모두 대응하도록 하는게 무척 어려웠습니다.

위에서 언급하였듯, 유저마다 최대로 모바일 기기를 움직이는 각도가 다르기 때문에,  
같은 기울임 수치를 가지더라도 Paddle의 위치는 유저별로 달라지게 됩니다.

게임을 플레이 하는, 각기 다른 사양의 모니터와 서로 다른 기울임 수치를 가진 모든 유저에게  
동일한 비율의 화면 구성을 보여주어야 하기 때문에 이를 계산하는게 무척 까다로웠습니다.

문제를 해결하기 위해, 게임에 참가한 각 유저들의 브라우저 창 사이즈를 측정하였습니다.  
너비 값들 중의 최솟값과, 높이 값들 중의 최솟값을 각각 구해,  
게임이 표시되는 영역은 앞서 구한 너비의 최솟값과 높이의 최솟값이 되도록 하였습니다.

이렇게 구현한다면 게임에 참가한 모든 유저가 똑같은 사이즈의 게임 화면을 볼 수 있게 되는 장점이 생기게 됩니다.

두 번째로 유저별 기울임 수치를 이용하여 Paddle의 위치를 나타내는 방법은  
일차방정식을 이용하여 Paddle의 위치를 계산하는 방법을 사용하였습니다.

&nbsp;

${PaddleEndPosition} = \frac{displayHeight - paddleLength}{lowerTiltLimit - upperTiltLimit}\times PaddleStartPosition - \frac{(displayHeight - paddleLength)\times upperTiltLimit}{lowerTiltLimit - upperTiltLimit}$

&nbsp;

### 모바일 기기 움직임으로 화면전환 구현

모바일 기기의 움직임을 통해 페이지 전환이 되게끔 하고자 하였는데,  
정확히 어떤 움직임을 취해야 하는지를 구상하는데 많은 시간이 들었습니다.

자이로 센서는 정지된 상태에서의 기울임만 감지할 수 있기 때문에  
모바일 기기를 허공에서 이리저리 움직이는 것은 하드웨어 특성상 불가능했으며  
직관적이면서도, 인식률이 아주 높은 방법을 떠올려야 했습니다.

결과적으로 떠올린 방법은 상하좌우의 움직임을 조합하여 페이지를 전환하는 것이었습니다.  
예를 들어 메뉴로 이동하고 싶으면 기기를 '상', 그리고 '우' 방향으로 움직이도록 하는 것입니다.

기기가 상하좌우의 움직임을 정확하게 감지하기 위해서는 현재 위치 지점의 센서 값을 기준으로  
상, 하, 좌, 우에 해당하는 값을 계산합니다.

모바일 기기가 움직임에 따라 센서의 값이 특정 임계값을 넘겼을 경우  
모바일 기기가 특정 방향으로 움직였다고 판단하는 원리를 이용했습니다.

값을 이용해 움직임을 감지하는 만큼, 이번 프로젝트에서는  
수학에서 많은 아이디어를 얻었습니다.

&nbsp;

### 화면 동기화 하기

게임을 구현할 때 requestAnimationFrame를 이용하여 canvas의 움직임을 표현하였습니다.  
requestAnimationFrame의 경우 자원을 절약하기 위해,  
사용자에게 보여지지 않는다면 애니메이션이 중도에 멈추는 특징이 있는데,  
실시간으로 계속해서 게임 정보를 보여줘야 하는 이번 프로젝트 입장에서는 이것은 큰 문제점으로 작용하였습니다.  
특정 유저가 게임이 실행중인 브라우저 창을 숨기거나 백그라운드로 넘기면  
같은 게임을 진행하고 있더라도, 게임 화면이 서로 달라지기 때문입니다.

게임 화면을 표현하는 애니메이션을 최대한 맞추기 위해 다양한 시도를 해보았습니다.  
resize 이벤트가 발생하거나, 임의로 게임 화면 브라우저를 닫은게 감지되면 게임을 중단시키는 방법이 그 예입니다.

그렇지만 저런 시도가 근본적인 해결책은 아니라는 생각이 들었습니다.  
결국 동기화를 통해 게임에 참여한 참가자의 게임 화면이 모두 같도록 맞춰줄 필요성이 있었습니다.

가장 먼저 시도한 것은  
일정한 시간 간격마다, 또는 벽이나 paddle에 ball이 부딛쳤을 때 ball의 위치를 동기화하는 방법이었습니다.  
소켓 통신을 이용하여 ball의 위치정보를 동기화 시켰으나, 이는 좋은 해결 방법이 되지 못했습니다.

왜냐하면, 게임 특성상 ball은 매 프레임마다 아주 매끄럽게 움직여야 하는데,  
ball이 움직이는 상황에서 위치가 갱신될때마다 애니메이션이 툭툭 하고 끊기며 움직임이 어그러졌기 때문입니다.  
이는 UX를 심각하게 떨어뜨렸으며, 심지어 유저간 애니메이션 차이를 더욱 벌어지게 만드는 결과를 낳았습니다.

많은 고민 끝에 찾은 해법은 매 라운드가 시작될 때마다 소켓 통신을 통해 동기화를 하는 방법이었습니다.  
게임 특성상 유저가 실점을 한다면 라운드가 끝난 뒤 다시 시작되고, ball은 중앙에서부터 다시 생성되어 움직이게 되는데,  
라운드가 끝나고 ball이 사라지고 나서, 게임에 참여한 모든 유저에게 동시에 ball이 생성되도록 소켓 통신을 보낸다면,  
애니메이션이 끊기지 않으면서, 화면 동기화 작업을 완벽히 수행할 수 있게 됩니다.

결과적으로, 실시간 서비스에서 동기화의 역할과 과정이 정말 중요한 것임을 경험할 수 있었습니다.

&nbsp;

## 실행방법

가장 먼저 접속할 경우 모바일 기기의 연동이 필요합니다.  
화면에 표시된 주소, 혹은 QR코드를 이용하여 모바일 기기를 접속시켜주세요  
![connection](/readme_assets/connection.jpg)

&nbsp;

지시에 따라 폰을 좌우로 기울여주세요  
![setting](/readme_assets/setting.gif)

&nbsp;

방을 생성하여 만들거나, 상대방이 생성한 방에 들어갈 수 있습니다.  
![gameList](/readme_assets/gameList.jpg)

&nbsp;

모바일 기기를 가로로 잡고 플레이해주세요.  
나에게 향해오는 공을 튕겨야 합니다.  
![gamePlay](/readme_assets/gamePlay.gif)

&nbsp;

모바일 기기의 움직임을 이용하여 화면을 전환하고 싶을 경우  
환경설정에서 해당 옵션을 선택해주세요.  
이후 모바일 기기를 세로로 잡고 움직이면 이를 감지합니다.  
![movePage](/readme_assets/movePage.gif)

&nbsp;

또한 모바일 기기의 움직임을 통해 각종 버튼도 제어할 수 있습니다.  
![clickButton](/readme_assets/clickButton.gif)

&nbsp;

## 환경변수

### Frontend

<백엔드 서버의 url 주소를 입력하세요>

```
REACT_APP_SERVER_URL
```

### Backend

<사용하기를 원하는 특정 포트번호를 입력하세요.
입력하지 않을 경우 포트번호는 기본적으로 8000번을 사용합니다>

```
PORT
```
